(ns superperm.williams
  "Implement of this paper:
  [1307.2549] Hamiltonicity of the Cayley Digraph on the Symmetric Group Generated by σ = (1 2 ... n) and τ = (1 2)
https://arxiv.org/abs/1307.2549"
  (:use [superperm.core :refer (perm-set)])
  (:require [clojure.set :as cs]
            [clojure.java.shell :refer [sh]]))

(defn sigma [p]
  (concat (rest p) (take 1 p)))

(defn sigma-rev [p]
  (concat (take-last 1 p) (drop-last 1 p)))

(defn tau [p]
  (concat (reverse (take 2 p)) (drop 2 p)))

(defn alternating-cycle [start]
  (->> (iterate (fn [[_ _ p]] (let [n1 (tau p)
                                    n2 (sigma-rev n1)]
                                [p n1 n2]))
                [nil nil start])
       (take (count start))
       (rest)
       (mapcat (fn [[p dp srp]]
                 [[p dp] [srp dp]]))
       (set)))

(defn rot-origin
  "Return permutation of rotate `perm` that start with n"
  [p]
  (let [n (count p)
        s (concat p p)]
    (take (count p) (drop-while #(not= % n) s))))

(defn rot= [p1 p2]
  (= (rot-origin p1) (rot-origin p2)))

(defn sigma-edges [n]
  (set
   (for [p (perm-set n)]
     [p (sigma p)])))

(defn tau-edges [n]
  (set
   (for [p (perm-set n)]
     [p (tau p)])))

(defn reduce-union [coll]
  (reduce cs/union coll))

(defn sym-diff
  "対称差"
  [s1 s2]
  (cs/union (cs/difference s1 s2)
            (cs/difference s2 s1)))



(defn F [n r m]
  (set
   (filter #(= [n m r] (take 3 %))
           (perm-set n))))

(defn Y2 [n]
  (reduce-union
   (map #(F n % (inc (mod % (dec n)))) (range 1 n))))

(defn Y1 [n]
  (reduce-union
   (concat [#{(concat [1 n] (range 2 n))}]
           (map #(F n %1 %2) (range 1 n) (concat (range 2 n) [2])))))

(defn A2 [n]
  (reduce-union (map alternating-cycle (Y2 n))))

(defn A1 [n]
  (reduce-union (map alternating-cycle (Y1 n))))

(defn C2 [n]
  (sym-diff (sigma-edges n) (A2 n)))

(defn C1 [n]
  (sym-diff (sigma-edges n) (A1 n)))

(defn make-one-path [start es]
  (loop [cur start, e-rest es, path [start]]
    (let [e (first (filter (fn [[s d]] (= s cur)) e-rest))]
      (if (or (nil? e) (empty? e-rest))
        [path (disj e-rest e)]
        (recur (last e) (disj e-rest e) (conj path (last e)))))))

(defn edges->paths [edges]
  (loop [es edges, paths []]
    (if (empty? es)
      paths
      (let [[start _] (first es)
            [p r] (make-one-path start es)]
        (recur r (conj paths p))))))


(defn forward-tau? [p]
  (let [n (count p)
        m (second p)
        mp (filter #(not= m %) p)
        r (inc (mod (- m 2) (dec n)))]
    (and (not= n m)
         (= r (nth (drop-while #(not= n %) (concat mp mp)) 1)))))

(defn gen-cycle-cover [start]
  (let [n (count start)]
    (->> (iterate (fn [p]
                    (if (forward-tau? p)
                      (tau p)
                      (sigma p)))
                  start)
         (rest)
         (take-while #(not= start %))
         (concat [start]))))

(defn small-cycle [c2]
  (set (filter (fn [[p _]]
                 (let [n (count p)
                       rev (reverse (range 1 n))
                       rp (filter (partial not= n) p)]
                   (and
                    (or (= n (first p)) (= n (second p)))
                    (= rev (rot-origin rp)))))
               c2)))


;; alternating-cycle tree, Wilf Graph

(defn sigma-cycles [n]
  (let [heads (filter #(= n (first %)) (perm-set n))
        se (sigma-edges n)]
    (zipmap heads
            (map (fn [h] (cs/select #(rot= h (first %)) se))
                 heads))))

(defn perm->ac [p]
  (concat (take 1 p) (drop 2 p)))

(defn Y2-cycles [n]
  (let [ss (Y2 n)]
    (zipmap (map perm->ac ss)
            (map #(alternating-cycle %) ss))))

(defn cycle-connects [y2c sc]
  (for [[y ye] y2c, [s se] sc :when (not (empty? (cs/intersection ye se)))]
    [y s]))

(defn wilf [n]
  (cycle-connects (Y2-cycles n) (sigma-cycles n)))

(defn reduction [we]
  (let [r (->> we
               (group-by second)
               (map (fn [[_ v]] (map first v)))
               (filter #(< 1 (count %))))]
    (set r)))




;; Graphviz

(defn rad-pos [ox oy d len]
  (let [r (* 2 Math/PI (/ d 360))]
    [(+ ox (int (* len (Math/cos r))))
     (+ oy (int (* len (Math/sin r))))]))

(defn perm->pos3 [p]
  (let [[d od] (condp rot= p
                 [3 1 2] [0 2.5]
                 [3 2 1] [1 1])
        [ox oy] (rad-pos 0 0 (* d 180) 200)
        sd (count (take-while #(not= % (count p)) p))]
    [[ox oy]
     (rad-pos ox oy (* 120 (mod (+ sd od) (count p))) 100)]))

(defn perm->pos4 [p]
  (let [[d od] (condp rot= p
                 [4 1 2 3] [5 (- 3 1/6)]
                 [4 2 1 3] [4 1/6]
                 [4 2 3 1] [3 1.5]
                 [4 3 2 1] [2 (- 3 1/6)]
                 [4 3 1 2] [1 1/6]
                 [4 1 3 2] [0 1.5])
        [ox oy] (rad-pos 0 0 (+ (* d 60) -90) 300)
        sd (count (take-while #(not= % (count p)) p))]
    [[ox oy]
     (rad-pos ox oy (* 90 (mod (+ sd od -1) (count p))) 100)]))

(defn perm->pos [p]
  (condp = (count p)
    3 (perm->pos3 p)
    4 (perm->pos4 p)
    [[0 0] [0 0]]))


(defn rot->dot [n]
  (let [ps (perm-set n)
        rot (filter #(= n (first %)) ps)]
    (apply str
           (map #(let [[[ox oy] _] (perm->pos %)
                       s (apply str %)]
                   (format "r%s [label=\"[%s]\", shape=\"none\", pos=\"%d,%d!\", fontcolor=\"gray\"];\n"
                           s s ox oy))
                rot))))

(defn perms->dot [ps]
  (apply str
         (map (fn [v] (let [[_ [x y]] (perm->pos v)
                            s (apply str v)]
                        (format "v%s [label=\"%s\", shape=\"circle\", pos=\"%d,%d!\"];\n" s s x y)))
              ps)))

(defn vertex->dot [n]
  (str (rot->dot n)
       (perms->dot (perm-set n))))

(defn edges->dot
  ([edges] (edges->dot edges "black"))
  ([edges color]
   (apply str
          (mapcat (fn [[e1 e2]]
                 (let [style (if (= (sigma e1) e2)
                             "solid"
                             "dashed")]
                   (edges->dot [[e1 e2]] color style)))
               edges)))
  ([edges color style]
   (apply str
          (map (fn [[e1 e2]]
                 (format "v%s -> v%s [color=\"%s\", style=\"%s\"];\n" (apply str e1) (apply str e2) color style))
               edges))))

(defn draw-graph
  ([vertex-str edges-str name layout]
   (let [out (format "digraph cycleCover {\n%s\n%s\n}"
                     vertex-str
                     edges-str)]
     (spit (str name ".dot") out)
     (condp = layout
       :fix (sh "neato" "-n1" "-Tpng" (str name ".dot") "-o" (str name ".png"))
       :circle (sh "circo" "-Tpng" (str name ".dot") "-o" (str name ".png"))
       (sh "dot" "-Tpng" (str name ".dot") "-o" (str name ".png")))
     (sh "open" (str name ".png"))))
  ([vertex-str edges-str name]
   (draw-graph vertex-str edges-str name :flow)))

;(defn cycle-cover->graph [n filename]
;  (let [cc (C2 n)
;        se (edges->dot (cs/difference (sigma-edges n) cc) "black")
;        te (edges->dot (cs/difference (tau-edges n) cc) "black")]
;    (draw-graph (vertex->dot n) (str (edges->dot cc "red") se te) filename)))

(defn cycle-cover->graph [n filename]
  (let [c2 (C2 n)
        sc (small-cycle c2)
        bc (cs/difference c2 sc)
        se (cs/difference (sigma-edges n) c2)]
    (draw-graph (vertex->dot n)
                (str (edges->dot sc "blue")
                     (edges->dot bc "red")
                     (edges->dot se "gray"))
                filename
                (if (or (= n 3) (= n 4))
                  :fix
                  :flow))))


;; sigma,delta

(defn delta [p]
  (concat (drop 2 p) (reverse (take 2 p))))

(defn w2e? [p]
  (let [n (count p)
        f (first p)
        m (inc (mod (- f 2) (dec n)))
        r (nth (drop-while #(not= % n) (rest p)) 1
               (first (rest p)))]
    (and (not= n f)
         (= m r))))

(defn perm-path [n]
  (let [inter (concat [1] (range n 1 -1))
        start (delta inter)
        all (apply * (range 1 (inc n)))]
    (take all
          (iterate #(if (and (w2e? %) (not= % inter))
                      (delta %)
                      (sigma %))
                   start))))
